// ---------- S7 helpers ----------
function layoutFinalChars(){
  const sky = document.getElementById("sky");
  const sljy = document.getElementById("sljyFinal");
  const dcop = document.getElementById("dcopFinal");

  const w = sky.clientWidth;

  const leftPad = Math.max(18, w * 0.10);
  const rightPad = Math.max(18, w * 0.10);

  const charW = 92;
  const gap = 2; // ✅ closer together

  // dcop stays near the right, sljy is placed just to his left
  const dcopLeft = Math.max(leftPad + charW + gap, w - rightPad - charW);
  const sljyLeft = dcopLeft - charW - gap;

  sljy.style.left = sljyLeft + "px";
  dcop.style.left = dcopLeft + "px";

  // give sljyWalk an exact target (so walk ends correctly even on resize)
  sljy.style.setProperty("--sljyEnd", sljyLeft + "px");
}

let petalsStarted = false;
function startPetals(){
  if(petalsStarted) return;
  petalsStarted = true;
  const petals = document.getElementById("petals");
  setInterval(()=>{
    const s=document.createElement("span");
    s.style.left = (Math.random()*100) + "%";
    s.style.animationDuration = (5.5 + Math.random()*2.5) + "s";
    s.style.opacity = (0.65 + Math.random()*0.35);
    petals.appendChild(s);
    setTimeout(()=>s.remove(), 9000);
  }, 180);
}

function positionKissBetweenHeads(){
  const kiss = document.getElementById("kissIcon");
  const a = document.getElementById("sljyFinal").getBoundingClientRect();
  const b = document.getElementById("dcopFinal").getBoundingClientRect();
  const sky = document.getElementById("sky").getBoundingClientRect();

  const midX = ((a.left + a.right)/2 + (b.left + b.right)/2) / 2;

  // higher than name tags
  const topY = Math.min(a.top, b.top) - 68;

  const x = midX - sky.left;
  const y = topY - sky.top;

  kiss.style.left = x + "px";
  kiss.style.top = y + "px";
}

let finalSeqStarted = false;
let loveTimer = null;

async function startFinalSequence(){
  if(finalSeqStarted) return;
  finalSeqStarted = true;

  const sljy = document.getElementById("sljyFinal");
  const kiss = document.getElementById("kissIcon");

  // hard stop any stray audio
  try{
    kissAudio.pause(); kissAudio.currentTime = 0;
    loveAudio.pause(); loveAudio.currentTime = 0;
  }catch(e){}

  // keep happy low so kiss/love can be heard
  if(musicOn) happy.volume = 0.18;

  // walk + gentle head tilt
  sljy.classList.add("sljyWalk");
  sljy.classList.add("sljyHeadTilt");

  // when walk is done (~2.0s), show kiss and play kiss
  setTimeout(async ()=>{
    positionKissBetweenHeads();
    kiss.style.opacity = 1;

    // play kiss
    kissAudio.pause();
    kissAudio.currentTime = 0;
    kissAudio.volume = 1;
    await safePlay(kissAudio);

    startPetals();

    // ✅ LOVE PLAYS ONLY AFTER KISS ENDS (no more “misplaced halfway”)
    // Use onended + a fallback timer.
    if(loveTimer) clearTimeout(loveTimer);
    loveTimer = null;

    const playLoveOnce = async () => {
      try{
        kissAudio.onended = null;
      }catch(e){}
      loveAudio.pause();
      loveAudio.currentTime = 0;
      loveAudio.volume = 1;
      await safePlay(loveAudio);

      // restore happy to 0.25 after love starts
      if(musicOn) happy.volume = 0.25;
    };

    // primary: after kiss ends
    kissAudio.onended = () => { playLoveOnce(); };

    // fallback: if onended doesn’t fire reliably (rare), start love at 900ms
    loveTimer = setTimeout(()=>{ playLoveOnce(); }, 900);

  }, 2000);
}
